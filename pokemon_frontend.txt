
frontend/src/lib/contracts/addresses.json
{
  "nft": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "marketplace": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
}

frontend/src/app/layout.tsx
// src/app/layout.tsx
import type { Metadata } from 'next';
import './globals.css';
import ClientLayout from '@/components/ClientLayout';

export const metadata: Metadata = {
  title: 'Pokémon NFT Trading Platform',
  description: 'Trade and collect Pokémon cards as NFTs',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <ClientLayout>
          {children}
        </ClientLayout>
      </body>
    </html>
  );
}

frontend/src/app/page.tsx
// src/app/page.tsx
'use client';
import Link from 'next/link';
import Image from 'next/image';
import { useWeb3 } from '@/contexts/Web3Context';
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

// MintPokemon Component
function MintPokemon() {
  const { nftContract, account } = useWeb3();
  const [isMinting, setIsMinting] = useState(false);
  const [mintResult, setMintResult] = useState<string | null>(null);
  const [pokemonIndex, setPokemonIndex] = useState<number>(0);
  const [pokemonCount, setPokemonCount] = useState<number>(0);
  
  // Get the available Pokémon count when the component loads
  useEffect(() => {
    const getCount = async () => {
      if (nftContract) {
        try {
          const count = await nftContract.getAvailablePokemonCount();
          setPokemonCount(count);
        } catch (error) {
          console.error("Error getting Pokémon count:", error);
        }
      }
    };
    
    getCount();
  }, [nftContract]);
  
  const mintPokemon = async () => {
    if (!nftContract || !account) {
      setMintResult("Please connect your wallet first");
      return;
    }
    
    try {
      setIsMinting(true);
      setMintResult(null);
      
      console.log("Minting Pokémon #" + pokemonIndex + " for " + account);
      const tx = await nftContract.mintPokemon(pokemonIndex, account);
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      
      // Get the event from the transaction receipt
      const event = receipt.logs.find(
        (log: any) => log.fragment && log.fragment.name === 'PokemonMinted'
      );
      
      setMintResult(`Successfully minted Pokémon #${pokemonIndex}!`);
    } catch (error) {
      console.error("Error minting Pokémon:", error);
      setMintResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setIsMinting(false);
    }
  };
  
  const mintRandomPokemon = async () => {
    if (!nftContract || !account) {
      setMintResult("Please connect your wallet first");
      return;
    }
    
    try {
      setIsMinting(true);
      setMintResult(null);
      
      console.log("Minting random Pokémon for " + account);
      console.log("NFT Contract address:", nftContract.target);
      
      // Try with a different parameter order or without parameters
      // Some implementations might not require recipient as parameter
      try {
        // First attempt - standard implementation
        const tx = await nftContract.mintRandomPokemon(account, {
          value: ethers.parseEther("0.01")
        });
        
        // Wait for the transaction to be mined
        const receipt = await tx.wait();
        setMintResult("Successfully minted a random Pokémon!");
        return;
      } catch (firstError) {
        console.error("First attempt failed:", firstError);
        
        // Second attempt - try without recipient
        try {
          const tx = await nftContract.mintRandomPokemon({
            value: ethers.parseEther("0.01")
          });
          
          // Wait for the transaction to be mined
          const receipt = await tx.wait();
          setMintResult("Successfully minted a random Pokémon (second attempt)!");
          return;
        } catch (secondError) {
          console.error("Second attempt failed:", secondError);
          throw secondError;
        }
      }
    } catch (error) {
      console.error("Error minting random Pokémon:", error);
      setMintResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setIsMinting(false);
    }
  };
  
  // Display contract addresses for debugging
  const displayContractAddress = nftContract ? nftContract.target : "Not connected";
  
  return (
    <div className="bg-white p-6 rounded-lg shadow-md mt-8 max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">Mint a Pokémon Card</h2>
      
      {!account ? (
        <p className="text-red-600 mb-4">Please connect your wallet to mint Pokémon cards</p>
      ) : (
        <div>
          <p className="text-sm text-gray-500 mb-2">Connected to NFT contract: {displayContractAddress}</p>
          <p className="mb-4">Available Pokémon types: {pokemonCount ? pokemonCount.toString() : '0'}</p>
          
          <div className="flex flex-col sm:flex-row gap-4 mb-6">
            <div className="flex-1">
              <h3 className="font-semibold mb-2">Mint Specific Pokémon</h3>
              <div className="flex space-x-2">
                <input
                  type="number"
                  min="0"
                  max={pokemonCount ? Number(pokemonCount) - 1 : 0}
                  value={pokemonIndex}
                  onChange={(e) => setPokemonIndex(parseInt(e.target.value))}
                  className="p-2 border rounded w-20"
                />
                <button
                  onClick={mintPokemon}
                  disabled={isMinting || !pokemonCount || pokemonCount.toString() === "0"}
                  className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isMinting ? 'Minting...' : 'Mint Pokémon'}
                </button>
              </div>
            </div>
            
            <div className="flex-1">
              <h3 className="font-semibold mb-2">Mint Random Pokémon</h3>
              <button
                onClick={mintRandomPokemon}
                disabled={isMinting || !pokemonCount || pokemonCount.toString() === "0"}
                className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isMinting ? 'Minting...' : 'Mint Random (0.01 ETH)'}
              </button>
            </div>
          </div>
        </div>
      )}
      
      {mintResult && (
        <div className={`p-3 rounded ${mintResult.includes('Error') ? 'bg-red-50 text-red-800' : 'bg-green-50 text-green-800'}`}>
          {mintResult}
        </div>
      )}
    </div>
  );
}

// AccountDisplay Component
function AccountDisplay() {
  const { account } = useWeb3();
  
  return (
    <div className="bg-white p-4 rounded-lg shadow-md mb-6 max-w-4xl mx-auto">
      <h2 className="text-lg font-semibold mb-2">Wallet Status</h2>
      {account ? (
        <div className="flex items-center">
          <div className="bg-green-500 rounded-full h-3 w-3 mr-2"></div>
          <p>Connected: {`${account.substring(0, 6)}...${account.substring(account.length - 4)}`}</p>
        </div>
      ) : (
        <div className="flex items-center">
          <div className="bg-red-500 rounded-full h-3 w-3 mr-2"></div>
          <p>No wallet connected</p>
        </div>
      )}
    </div>
  );
}

// Import AddressChecker component
import AddressChecker from '@/components/AddressChecker';

export default function Home() {
  const { account } = useWeb3();
  
  return (
    <div className="text-center">
      <h1 className="text-4xl font-bold mb-6">Welcome to Pokémon NFT Trading Platform</h1>
      <p className="text-xl mb-8">Collect, trade, and own your favorite Pokémon as NFTs</p>
      
      <AccountDisplay />
      <AddressChecker />
      
      <div className="flex flex-col md:flex-row justify-center gap-6 max-w-4xl mx-auto">
        <Link 
          href="/marketplace"
          className="bg-blue-600 text-white p-6 rounded-lg shadow-md hover:bg-blue-700 transition flex-1"
        >
          <h2 className="text-2xl font-bold mb-3">Browse Marketplace</h2>
          <p>Discover and purchase Pokémon cards from other trainers</p>
        </Link>
        
        <Link 
          href="/my-collection"
          className="bg-green-600 text-white p-6 rounded-lg shadow-md hover:bg-green-700 transition flex-1"
        >
          <h2 className="text-2xl font-bold mb-3">My Collection</h2>
          <p>View your Pokémon card collection and list cards for sale</p>
        </Link>
      </div>
      
      <MintPokemon />
      
      <div className="mt-12">
        <h2 className="text-2xl font-bold mb-4">Featured Pokémon</h2>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 max-w-4xl mx-auto">
          {/* Placeholder for featured Pokémon - would be dynamic in final version */}
          {[1, 4, 7, 25].map((id) => (
            <div key={id} className="bg-white p-4 rounded-lg shadow-md">
              <div className="bg-gray-100 h-40 w-full rounded flex items-center justify-center">
                <img 
                  src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`}
                  alt={`Pokemon #${id}`}
                  className="h-32 w-32 object-contain"
                />
              </div>
              <p className="mt-2 font-medium">
                {id === 1 ? "Bulbasaur" : 
                 id === 4 ? "Charmander" : 
                 id === 7 ? "Squirtle" : 
                 id === 25 ? "Pikachu" : `Pokémon #${id}`}
              </p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

frontend/src/app/globals.css
@import "tailwindcss";


frontend/src/app/favicon.ico
[Error reading file: 'utf-8' codec can't decode byte 0x96 in position 50: invalid start byte]

frontend/src/app/my-collection/page.tsx
// src/app/my-collection/page.tsx
'use client';

import { useWeb3 } from '@/contexts/Web3Context';
import ListingCreator from '@/components/ListingCreator';

export default function MyCollection() {
  const { account } = useWeb3();
  
  return (
    <div>
      <h1 className="text-3xl font-bold mb-6 text-center">My Pokémon Collection</h1>
      
      {!account ? (
        <div className="bg-white p-8 rounded-lg shadow-md text-center max-w-2xl mx-auto">
          <p className="text-xl mb-4">Please connect your wallet to view your collection</p>
          <p className="text-gray-600">
            Connect your wallet to view your Pokémon and list them for sale on the marketplace
          </p>
        </div>
      ) : (
        <ListingCreator />
      )}
    </div>
  );
}

frontend/src/app/marketplace/page.tsx
// src/app/marketplace/page.tsx
'use client';

import { useWeb3 } from '@/contexts/Web3Context';
import MarketplaceBrowser from '@/components/MarketplaceBrowser';

export default function Marketplace() {
  const { account, connectWallet, isConnecting } = useWeb3();
  
  return (
    <div>
      <h1 className="text-3xl font-bold mb-6 text-center">Pokémon Marketplace</h1>
      
      {!account ? (
        <div className="bg-white p-8 rounded-lg shadow-md text-center max-w-2xl mx-auto mb-8">
          <p className="text-xl mb-4">Connect your wallet to purchase Pokémon</p>
          <button
            onClick={connectWallet}
            disabled={isConnecting}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
          >
            {isConnecting ? 'Connecting...' : 'Connect Wallet'}
          </button>
        </div>
      ) : null}
      
      <MarketplaceBrowser />
    </div>
  );
}

frontend/src/components/MarketplaceBrowser.tsx
// src/components/MarketplaceBrowser.tsx
'use client';

import { useState, useEffect } from 'react';
import { useWeb3 } from '@/contexts/Web3Context';
import { ethers } from 'ethers';

type ListedPokemon = {
  listingId: string;
  tokenId: string;
  pokemonId: string;
  name: string;
  type: string;
  rarity: string;
  imageUrl: string;
  price: string;
  seller: string;
};

export default function MarketplaceBrowser() {
  const { account, nftContract, marketplaceContract } = useWeb3();
  const [listedPokemon, setListedPokemon] = useState<ListedPokemon[]>([]);
  const [loading, setLoading] = useState(true);
  const [purchasing, setPurchasing] = useState<string | null>(null);
  const [purchaseResult, setPurchaseResult] = useState<string | null>(null);
  
  // Fetch active listings
  useEffect(() => {
    const fetchListings = async () => {
      if (!nftContract || !marketplaceContract) return;
      
      try {
        setLoading(true);
        
        // Get count of active listings
        let listingCount;
        try {
          listingCount = await marketplaceContract.getActiveListingCount();
        } catch (error) {
          console.error("Error getting active listing count:", error);
          
          // Fallback: try iterating through listings until we find none
          listingCount = 100; // Try a reasonable maximum
        }
        
        // Array to store listed Pokémon
        const listedPokemonArray: ListedPokemon[] = [];
        
        // Approach 1: Use the count and go through each listing
        for (let i = 1; i <= listingCount; i++) {
          try {
            const listing = await marketplaceContract.listings(i);
            
            // Check if listing is active (status = 0 typically means active)
            if (listing && Number(listing.status) === 0) {
              // Get the Pokemon data for this token
              const pokemon = await nftContract.pokemonData(listing.tokenId);
              
              listedPokemonArray.push({
                listingId: i.toString(),
                tokenId: listing.tokenId.toString(),
                pokemonId: pokemon.pokemonId.toString(),
                name: pokemon.name,
                type: pokemon.pokemonType,
                rarity: pokemon.rarity,
                imageUrl: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${pokemon.pokemonId}.png`,
                price: ethers.formatEther(listing.price),
                seller: listing.seller
              });
            }
          } catch (error) {
            console.error(`Error fetching listing #${i}:`, error);
            
            // If we've gone past the actual number of listings, break out of the loop
            if (error.message && (
              error.message.includes("invalid array length") || 
              error.message.includes("invalid storage location")
            )) {
              break;
            }
          }
        }
        
        setListedPokemon(listedPokemonArray);
      } catch (error) {
        console.error("Error fetching listings:", error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchListings();
  }, [nftContract, marketplaceContract, purchasing]);
  
  const purchasePokemon = async (listingId: string, price: string) => {
    if (!marketplaceContract || !account) {
      setPurchaseResult("Please connect your wallet");
      return;
    }
    
    try {
      setPurchasing(listingId);
      setPurchaseResult(null);
      
      // Convert price from ETH to wei
      const priceInWei = ethers.parseEther(price);
      
      // Purchase the listing
      console.log(`Purchasing listing #${listingId} for ${price} ETH...`);
      const tx = await marketplaceContract.buyListing(listingId, {
        value: priceInWei
      });
      await tx.wait();
      
      setPurchaseResult(`Successfully purchased Pokémon for ${price} ETH!`);
      
      // Remove this listing from the UI
      setListedPokemon(prevListings => 
        prevListings.filter(listing => listing.listingId !== listingId)
      );
    } catch (error) {
      console.error("Error purchasing Pokémon:", error);
      
      // Check for specific errors
      if (error.message && error.message.includes("insufficient funds")) {
        setPurchaseResult("Error: You don't have enough ETH to purchase this Pokémon");
      } else if (error.message && error.message.includes("Listing is not active")) {
        setPurchaseResult("Error: This listing is no longer active");
      } else {
        setPurchaseResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } finally {
      setPurchasing(null);
    }
  };
  
  return (
    <div className="bg-white p-6 rounded-lg shadow-md mt-8 max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">Pokémon Marketplace</h2>
      
      {loading ? (
        <p className="text-center py-4">Loading marketplace listings...</p>
      ) : listedPokemon.length === 0 ? (
        <div className="text-center py-4 border rounded-lg bg-gray-50">
          <p className="mb-3">No Pokémon are currently listed for sale.</p>
          <a href="/my-collection" className="text-blue-600 hover:underline">
            List your Pokémon for sale
          </a>
        </div>
      ) : (
        <div>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
            {listedPokemon.map((pokemon) => (
              <div 
                key={pokemon.listingId}
                className="border rounded-lg p-4 flex flex-col"
              >
                <div className="bg-gray-50 rounded-lg p-3 mb-3 flex-grow">
                  <img 
                    src={pokemon.imageUrl} 
                    alt={pokemon.name} 
                    className="h-32 w-32 object-contain mx-auto"
                  />
                </div>
                
                <div className="text-center">
                  <h3 className="font-semibold text-lg">{pokemon.name}</h3>
                  <p className="text-sm text-gray-600">{pokemon.type} • {pokemon.rarity}</p>
                  <p className="text-sm mb-2">Token #{pokemon.tokenId}</p>
                  
                  <div className="bg-blue-50 rounded-lg py-2 px-3 mb-3">
                    <p className="font-medium text-blue-800">{pokemon.price} ETH</p>
                  </div>
                  
                  {account && pokemon.seller.toLowerCase() === account.toLowerCase() ? (
                    <p className="text-sm text-gray-500 italic">You own this listing</p>
                  ) : (
                    <button
                      onClick={() => purchasePokemon(pokemon.listingId, pokemon.price)}
                      disabled={purchasing !== null}
                      className="w-full py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {purchasing === pokemon.listingId ? 'Purchasing...' : 'Buy Now'}
                    </button>
                  )}
                </div>
              </div>
            ))}
          </div>
          
          {purchaseResult && (
            <div className={`p-3 rounded mt-6 ${
              purchaseResult.includes('Error') 
                ? 'bg-red-50 text-red-800' 
                : 'bg-green-50 text-green-800'
            }`}>
              {purchaseResult}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

frontend/src/components/ListingCreator.tsx
// src/components/ListingCreator.tsx
'use client';

import { useState, useEffect } from 'react';
import { useWeb3 } from '@/contexts/Web3Context';
import { ethers } from 'ethers';

type OwnedPokemon = {
  tokenId: string;
  pokemonId: string;
  name: string;
  type: string;
  rarity: string;
  imageUrl: string;
  isListed: boolean;
};

export default function ListingCreator() {
  const { account, nftContract, marketplaceContract } = useWeb3();
  const [ownedPokemon, setOwnedPokemon] = useState<OwnedPokemon[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedToken, setSelectedToken] = useState<string>('');
  const [price, setPrice] = useState<string>('0.1');
  const [isCreatingListing, setIsCreatingListing] = useState(false);
  const [listingResult, setListingResult] = useState<string | null>(null);
  
  // Fetch user's owned Pokémon
  useEffect(() => {
    const fetchOwnedPokemon = async () => {
      if (!nftContract || !account || !marketplaceContract) return;
      
      try {
        setLoading(true);
        
        // Get the balance of the user (how many tokens they own)
        const balance = await nftContract.balanceOf(account);
        
        // Array to store owned Pokémon
        const ownedPokemonArray: OwnedPokemon[] = [];
        
        // Loop through each token owned by the user
        for (let i = 0; i < Number(balance); i++) {
          try {
            // Get the token ID at index i in the user's collection
            const tokenId = await nftContract.tokenOfOwnerByIndex(account, i);
            
            // Get the Pokémon data for this token
            const pokemon = await nftContract.pokemonData(tokenId);
            
            // Check if this token is already listed
            let isListed = false;
            try {
              isListed = await marketplaceContract.isTokenListed(tokenId);
            } catch (error) {
              console.log("Error checking if token is listed:", error);
              // Alternative approach if isTokenListed doesn't exist
              try {
                // Try to get the listing ID from tokenId mapping
                const listingId = await marketplaceContract.tokenIdToListingId(tokenId);
                if (Number(listingId) > 0) {
                  const listing = await marketplaceContract.listings(listingId);
                  // Check if listing is active (status = 0)
                  isListed = listing && listing.status === 0;
                }
              } catch (mapError) {
                console.log("Error checking mapping:", mapError);
              }
            }
            
            // Add the Pokémon to the owned array if it's not listed
            ownedPokemonArray.push({
              tokenId: tokenId.toString(),
              pokemonId: pokemon.pokemonId.toString(),
              name: pokemon.name,
              type: pokemon.pokemonType,
              rarity: pokemon.rarity,
              imageUrl: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${pokemon.pokemonId}.png`,
              isListed: isListed
            });
          } catch (error) {
            console.error(`Error fetching token #${i}:`, error);
          }
        }
        
        setOwnedPokemon(ownedPokemonArray);
      } catch (error) {
        console.error("Error fetching owned Pokémon:", error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchOwnedPokemon();
  }, [nftContract, account, marketplaceContract]);
  
  const createListing = async () => {
    if (!nftContract || !marketplaceContract || !account || !selectedToken) {
      setListingResult("Please connect your wallet and select a Pokémon");
      return;
    }
    
    try {
      setIsCreatingListing(true);
      setListingResult(null);
      
      // First, approve the marketplace contract to transfer this token
      console.log("Approving marketplace to transfer token...");
      const approvalTx = await nftContract.approve(
        await marketplaceContract.getAddress(),
        selectedToken
      );
      await approvalTx.wait();
      console.log("Approval confirmed");
      
      // Convert price from ETH to wei
      const priceInWei = ethers.parseEther(price);
      
      // Create the listing
      console.log("Creating listing...");
      const tx = await marketplaceContract.createListing(selectedToken, priceInWei);
      await tx.wait();
      
      setListingResult(`Successfully listed Pokémon for ${price} ETH!`);
      
      // Update the UI to show this token is now listed
      setOwnedPokemon(prevState => 
        prevState.map(pokemon => 
          pokemon.tokenId === selectedToken 
            ? { ...pokemon, isListed: true } 
            : pokemon
        )
      );
      
      // Reset selected token
      setSelectedToken('');
    } catch (error) {
      console.error("Error creating listing:", error);
      
      // Check for specific errors
      if (error.message && error.message.includes("Marketplace not approved")) {
        setListingResult("Error: Marketplace needs approval to transfer your Pokémon");
      } else if (error.message && error.message.includes("already listed")) {
        setListingResult("Error: This Pokémon is already listed for sale");
      } else {
        setListingResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } finally {
      setIsCreatingListing(false);
    }
  };
  
  return (
    <div className="bg-white p-6 rounded-lg shadow-md mt-8 max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">List a Pokémon for Sale</h2>
      
      {!account ? (
        <p className="text-red-600 mb-4">Please connect your wallet to list Pokémon</p>
      ) : loading ? (
        <p className="text-center py-4">Loading your Pokémon collection...</p>
      ) : ownedPokemon.length === 0 ? (
        <div className="text-center py-4">
          <p className="mb-3">You don't own any Pokémon cards yet.</p>
          <a href="/" className="text-blue-600 hover:underline">Mint some Pokémon first</a>
        </div>
      ) : (
        <div>
          <div className="mb-6">
            <h3 className="font-semibold mb-2">Your Pokémon Collection</h3>
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
              {ownedPokemon.map((pokemon) => (
                <div 
                  key={pokemon.tokenId}
                  onClick={() => !pokemon.isListed && setSelectedToken(pokemon.tokenId)}
                  className={`border rounded-lg p-2 text-center cursor-pointer transition ${
                    pokemon.isListed 
                      ? 'opacity-50 cursor-not-allowed bg-gray-100' 
                      : selectedToken === pokemon.tokenId 
                        ? 'border-blue-500 bg-blue-50' 
                        : 'hover:border-gray-400'
                  }`}
                >
                  <div className="bg-gray-50 rounded-lg p-2 mb-2">
                    <img 
                      src={pokemon.imageUrl} 
                      alt={pokemon.name} 
                      className="h-20 w-20 object-contain mx-auto"
                    />
                  </div>
                  <p className="font-medium">{pokemon.name}</p>
                  <p className="text-xs text-gray-500">Token #{pokemon.tokenId}</p>
                  {pokemon.isListed && (
                    <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full mt-1 inline-block">
                      Listed
                    </span>
                  )}
                </div>
              ))}
            </div>
          </div>
          
          <div className="border-t pt-4">
            <h3 className="font-semibold mb-3">Create Listing</h3>
            
            {selectedToken ? (
              <div>
                <p className="mb-2">
                  Selected Pokémon: {ownedPokemon.find(p => p.tokenId === selectedToken)?.name} 
                  (Token #{selectedToken})
                </p>
                
                <div className="flex items-end gap-3 mb-4">
                  <div className="flex-1">
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Price (ETH)
                    </label>
                    <input
                      type="number"
                      step="0.01"
                      min="0.01"
                      value={price}
                      onChange={(e) => setPrice(e.target.value)}
                      className="p-2 border rounded w-full"
                    />
                  </div>
                  
                  <button
                    onClick={createListing}
                    disabled={isCreatingListing}
                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {isCreatingListing ? 'Creating Listing...' : 'List for Sale'}
                  </button>
                </div>
              </div>
            ) : (
              <p className="text-gray-500 italic">
                Select a Pokémon above to list it for sale
              </p>
            )}
          </div>
          
          {listingResult && (
            <div className={`p-3 rounded mt-4 ${
              listingResult.includes('Error') 
                ? 'bg-red-50 text-red-800' 
                : 'bg-green-50 text-green-800'
            }`}>
              {listingResult}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

frontend/src/components/WalletConnect.tsx
// src/components/WalletConnect.tsx
'use client';
import { useWeb3 } from '@/contexts/Web3Context';

export default function WalletConnect() {
  const { account, connectWallet, isConnecting, error } = useWeb3();
  
  return (
    <div>
      {account ? (
        <div className="px-4 py-2 bg-blue-700 rounded-md font-medium">
          {`${account.substring(0, 6)}...${account.substring(account.length - 4)}`}
        </div>
      ) : (
        <button
          onClick={connectWallet}
          disabled={isConnecting}
          className="px-4 py-2 bg-blue-700 hover:bg-blue-800 rounded-md font-medium transition disabled:opacity-70"
        >
          {isConnecting ? 'Connecting...' : 'Connect Wallet'}
        </button>
      )}
      {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
    </div>
  );
}

frontend/src/components/Navbar.tsx
// src/components/Navbar.tsx
import Link from 'next/link';
import WalletConnect from './WalletConnect';

export default function Navbar() {
  return (
    <nav className="bg-blue-600 text-white shadow-md">
      <div className="container mx-auto px-4 py-3 flex justify-between items-center">
        <div className="flex items-center space-x-8">
          <Link href="/" className="text-xl font-bold">Pokémon NFT</Link>
          <div className="hidden md:flex space-x-6">
            <Link href="/" className="hover:text-blue-200 transition">Home</Link>
            <Link href="/marketplace" className="hover:text-blue-200 transition">Marketplace</Link>
            <Link href="/my-collection" className="hover:text-blue-200 transition">My Collection</Link>
          </div>
        </div>
        <WalletConnect />
      </div>
    </nav>
  );
}

frontend/src/components/MintPokemon.tsx
// src/components/MintPokemon.tsx
'use client';

import { useState, useEffect } from 'react';
import { useWeb3 } from '@/contexts/Web3Context';
import { ethers } from 'ethers';

export default function MintPokemon() {
  const { nftContract, account } = useWeb3();
  const [isMinting, setIsMinting] = useState(false);
  const [mintResult, setMintResult] = useState<string | null>(null);
  const [pokemonIndex, setPokemonIndex] = useState<number>(0);
  const [pokemonCount, setPokemonCount] = useState<number>(0);
  const [mintPrice, setMintPrice] = useState<string>("0.01");
  const [availablePokemon, setAvailablePokemon] = useState<any[]>([]);
  
  // Get the available Pokémon count and mint price when the component loads
  useEffect(() => {
    const getContractInfo = async () => {
      if (nftContract) {
        try {
          // Get available Pokémon count
          const count = await nftContract.getAvailablePokemonCount();
          setPokemonCount(count);
          
          // Try to get mint price if the function exists
          try {
            const price = await nftContract.mintPrice();
            setMintPrice(ethers.formatEther(price));
          } catch (error) {
            console.log("Mint price function not available, using default");
          }
          
          // Get available Pokémon data for display
          const pokemonList = [];
          for (let i = 0; i < Number(count); i++) {
            try {
              const pokemon = await nftContract.availablePokemon(i);
              pokemonList.push({
                id: pokemon.pokemonId.toString(),
                name: pokemon.name,
                type: pokemon.pokemonType,
                rarity: pokemon.rarity,
                maxSupply: pokemon.maxSupply.toString(),
                currentSupply: pokemon.currentSupply.toString()
              });
            } catch (error) {
              console.error(`Error fetching Pokémon at index ${i}:`, error);
            }
          }
          setAvailablePokemon(pokemonList);
        } catch (error) {
          console.error("Error getting contract information:", error);
        }
      }
    };
    
    getContractInfo();
  }, [nftContract]);
  
  const mintPokemon = async () => {
    if (!nftContract || !account) {
      setMintResult("Please connect your wallet first");
      return;
    }
    
    try {
      setIsMinting(true);
      setMintResult(null);
      
      console.log("Minting Pokémon #" + pokemonIndex + " for " + account);
      
      // Send ETH with the transaction (used for both owner and non-owner versions)
      const tx = await nftContract.mintPokemon(pokemonIndex, account, {
        value: ethers.parseEther(mintPrice)
      });
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      
      setMintResult(`Successfully minted Pokémon #${pokemonIndex}!`);
      
      // Refresh Pokémon data after minting
      if (availablePokemon[pokemonIndex]) {
        try {
          const pokemon = await nftContract.availablePokemon(pokemonIndex);
          const updatedPokemon = [...availablePokemon];
          updatedPokemon[pokemonIndex] = {
            ...updatedPokemon[pokemonIndex],
            currentSupply: pokemon.currentSupply.toString()
          };
          setAvailablePokemon(updatedPokemon);
        } catch (error) {
          console.error("Error updating Pokémon data:", error);
        }
      }
    } catch (error) {
      console.error("Error minting Pokémon:", error);
      
      // More specific error messaging
      if (error.message && error.message.includes("onlyOwner")) {
        setMintResult("Error: Only the contract owner can mint specific Pokémon");
      } else if (error.message && error.message.includes("maximum supply")) {
        setMintResult("Error: This Pokémon has reached its maximum supply");
      } else {
        setMintResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } finally {
      setIsMinting(false);
    }
  };
  
  const mintRandomPokemon = async () => {
    if (!nftContract || !account) {
      setMintResult("Please connect your wallet first");
      return;
    }
    
    try {
      setIsMinting(true);
      setMintResult(null);
      
      console.log("Minting random Pokémon for " + account);
      console.log("NFT Contract address:", nftContract.target);
      
      // Try with and without recipient parameter
      try {
        // First attempt - pass recipient explicitly
        const tx = await nftContract.mintRandomPokemon(account, {
          value: ethers.parseEther(mintPrice)
        });
        
        const receipt = await tx.wait();
        setMintResult("Successfully minted a random Pokémon!");
      } catch (firstError) {
        console.error("First attempt failed:", firstError);
        
        // Second attempt - use msg.sender (don't pass recipient)
        try {
          const tx = await nftContract.mintRandomPokemon({
            value: ethers.parseEther(mintPrice)
          });
          
          const receipt = await tx.wait();
          setMintResult("Successfully minted a random Pokémon!");
        } catch (secondError) {
          console.error("Second attempt failed:", secondError);
          
          // Final attempt - try simpleMint
          try {
            const tx = await nftContract.simpleMint({
              value: ethers.parseEther(mintPrice)
            });
            
            const receipt = await tx.wait();
            setMintResult("Successfully minted a Pokémon using simpleMint!");
          } catch (thirdError) {
            console.error("Third attempt failed:", thirdError);
            throw thirdError;
          }
        }
      }
    } catch (error) {
      console.error("Error minting random Pokémon:", error);
      setMintResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setIsMinting(false);
    }
  };
  
  return (
    <div className="bg-white p-6 rounded-lg shadow-md mt-8 max-w-4xl mx-auto">
      <h2 className="text-2xl font-bold mb-4">Mint a Pokémon Card</h2>
      
      {!account ? (
        <p className="text-red-600 mb-4">Please connect your wallet to mint Pokémon cards</p>
      ) : (
        <div>
          <p className="text-sm text-gray-500 mb-2">Connected to NFT contract: {nftContract?.target || "Not connected"}</p>
          <p className="mb-4">Available Pokémon types: {pokemonCount ? pokemonCount.toString() : '0'}</p>
          <p className="mb-4">Mint price: {mintPrice} ETH</p>
          
          {availablePokemon.length > 0 && (
            <div className="mb-6">
              <h3 className="font-semibold mb-2">Available Pokémon:</h3>
              <div className="max-h-40 overflow-y-auto p-2 border rounded">
                <table className="w-full text-left text-sm">
                  <thead>
                    <tr className="border-b">
                      <th className="p-1">Index</th>
                      <th className="p-1">Name</th>
                      <th className="p-1">Type</th>
                      <th className="p-1">Rarity</th>
                      <th className="p-1">Supply</th>
                    </tr>
                  </thead>
                  <tbody>
                    {availablePokemon.map((pokemon, index) => (
                      <tr key={index} className="border-b hover:bg-gray-50">
                        <td className="p-1">{index}</td>
                        <td className="p-1">{pokemon.name}</td>
                        <td className="p-1">{pokemon.type}</td>
                        <td className="p-1">{pokemon.rarity}</td>
                        <td className="p-1">{pokemon.currentSupply}/{pokemon.maxSupply}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
          
          <div className="flex flex-col sm:flex-row gap-4 mb-6">
            <div className="flex-1">
              <h3 className="font-semibold mb-2">Mint Specific Pokémon</h3>
              <div className="flex space-x-2">
                <input
                  type="number"
                  min="0"
                  max={pokemonCount ? Number(pokemonCount) - 1 : 0}
                  value={pokemonIndex}
                  onChange={(e) => setPokemonIndex(parseInt(e.target.value))}
                  className="p-2 border rounded w-20"
                />
                <button
                  onClick={mintPokemon}
                  disabled={isMinting || !pokemonCount || pokemonCount.toString() === "0"}
                  className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isMinting ? 'Minting...' : `Mint (${mintPrice} ETH)`}
                </button>
              </div>
            </div>
            
            <div className="flex-1">
              <h3 className="font-semibold mb-2">Mint Random Pokémon</h3>
              <button
                onClick={mintRandomPokemon}
                disabled={isMinting || !pokemonCount || pokemonCount.toString() === "0"}
                className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isMinting ? 'Minting...' : `Mint Random (${mintPrice} ETH)`}
              </button>
            </div>
          </div>
        </div>
      )}
      
      {mintResult && (
        <div className={`p-3 rounded ${mintResult.includes('Error') ? 'bg-red-50 text-red-800' : 'bg-green-50 text-green-800'}`}>
          {mintResult}
        </div>
      )}
    </div>
  );
}

frontend/src/components/PokemonCard.tsx
// src/components/PokemonCard.tsx
import Image from 'next/image';
import Link from 'next/link';

type PokemonCardProps = {
  id: number;
  tokenId: number;
  name: string;
  imageUrl: string;
  type: string;
  rarity: string;
  price?: string;
  isListed?: boolean;
};

export default function PokemonCard({
  id,
  tokenId,
  name,
  imageUrl,
  type,
  rarity,
  price,
  isListed
}: PokemonCardProps) {
  // Map rarity to color
  const rarityColors = {
    'Common': 'bg-gray-200',
    'Uncommon': 'bg-green-200',
    'Rare': 'bg-blue-200',
    'Ultra Rare': 'bg-purple-200',
    'Legendary': 'bg-yellow-200'
  };
  
  const rarityColor = rarityColors[rarity as keyof typeof rarityColors] || 'bg-gray-200';
  
  return (
    <Link href={`/card/${tokenId}`}>
      <div className="bg-white rounded-lg shadow-md overflow-hidden transition-transform hover:scale-105">
        <div className="relative h-48 w-full">
          {imageUrl ? (
            <Image
              src={imageUrl}
              alt={name}
              fill
              className="object-contain"
            />
          ) : (
            <div className="absolute inset-0 bg-gray-200 flex items-center justify-center">
              <p className="text-gray-500">No Image</p>
            </div>
          )}
        </div>
        
        <div className="p-4">
          <div className="flex justify-between items-start mb-2">
            <h3 className="font-bold text-lg">{name}</h3>
            <span className={`text-xs px-2 py-1 rounded ${rarityColor}`}>
              {rarity}
            </span>
          </div>
          
          <p className="text-sm text-gray-600 mb-3">Type: {type}</p>
          
          {isListed && price && (
            <div className="mt-2 pt-2 border-t border-gray-200">
              <p className="text-blue-600 font-medium">{price} ETH</p>
            </div>
          )}
          
          {isListed && (
            <div className="mt-2 bg-blue-600 text-white text-center py-1 rounded-md text-sm">
              Listed for Sale
            </div>
          )}
        </div>
      </div>
    </Link>
  );
}

frontend/src/components/ClientLayout.tsx
// src/components/ClientLayout.tsx
'use client';

import { Web3Provider } from '@/contexts/Web3Context';
import Navbar from './Navbar';

export default function ClientLayout({ children }: { children: React.ReactNode }) {
  return (
    <Web3Provider>
      <div className="min-h-screen bg-gray-100">
        <Navbar />
        <main className="container mx-auto py-8 px-4">
          {children}
        </main>
      </div>
    </Web3Provider>
  );
}

frontend/src/components/AccountDisplay.tsx
// src/components/AccountDisplay.tsx
'use client';

import { useWeb3 } from '@/contexts/Web3Context';
import { useEffect, useState } from 'react';

export default function AccountDisplay() {
  const { account } = useWeb3();
  const [currentTime, setCurrentTime] = useState(new Date());
  
  // Force re-render every few seconds to ensure we have the latest account
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 3000);
    
    return () => clearInterval(timer);
  }, []);
  
  return (
    <div className="bg-white p-4 rounded-lg shadow-md">
      <h2 className="text-lg font-semibold mb-2">Current Account</h2>
      {account ? (
        <div>
          <p className="text-gray-700 break-all">{account}</p>
          <p className="text-sm text-gray-500 mt-1">
            Last checked: {currentTime.toLocaleTimeString()}
          </p>
        </div>
      ) : (
        <p className="text-red-500">No account connected</p>
      )}
    </div>
  );
}

frontend/src/components/CardGrid.tsx
// src/components/CardGrid.tsx
import PokemonCard from './PokemonCard';

type CardData = {
  id: number;
  tokenId: number;
  name: string;
  imageUrl: string;
  type: string;
  rarity: string;
  price?: string;
  isListed?: boolean;
  listingId?: number;
  isAuction?: boolean;
};

type CardGridProps = {
  cards: CardData[];
};

export default function CardGrid({ cards }: CardGridProps) {
  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {cards.map((card) => (
        <PokemonCard
          key={card.tokenId}
          id={card.id}
          tokenId={card.tokenId}
          name={card.name}
          imageUrl={card.imageUrl}
          type={card.type}
          rarity={card.rarity}
          price={card.price}
          isListed={card.isListed}
        />
      ))}
    </div>
  );
}

frontend/src/components/SimpleMinter.tsx
// src/components/SimpleMinter.tsx
'use client';

import { useState } from 'react';
import { useWeb3 } from '@/contexts/Web3Context';

export default function SimpleMinter() {
  const { nftContract, account } = useWeb3();
  const [isMinting, setIsMinting] = useState(false);
  const [result, setResult] = useState<string | null>(null);
  const [pokemonIndex, setPokemonIndex] = useState<number>(0);
  
  const mintPokemon = async () => {
    if (!nftContract || !account) {
      setResult("Please connect your wallet first");
      return;
    }
    
    try {
      setIsMinting(true);
      setResult(null);
      
      console.log("Minting with account:", account);
      console.log("Contract target:", nftContract.target);

      // Try the mintPokemon function first
      const tx = await nftContract.mintPokemon(pokemonIndex, account);
      await tx.wait();
      
      setResult(`Successfully minted Pokémon #${pokemonIndex}!`);
    } catch (mintError) {
      console.error("Error with mintPokemon:", mintError);
      
      try {
        // If that fails, try the simpleMint function
        console.log("Trying simpleMint instead...");
        const tx = await nftContract.simpleMint(account);
        await tx.wait();
        
        setResult("Successfully minted a Pokémon using simpleMint!");
      } catch (error) {
        console.error("Error with simpleMint:", error);
        setResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } finally {
      setIsMinting(false);
    }
  };
  
  const checkPokemonCount = async () => {
    if (!nftContract) {
      setResult("Please connect your wallet first");
      return;
    }
    
    try {
      const count = await nftContract.getAvailablePokemonCount();
      setResult(`There are ${count.toString()} available Pokémon types`);
    } catch (error) {
      console.error("Error checking Pokémon count:", error);
      setResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
    }
  };
  
  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-4">Mint a Pokémon</h2>
      
      <div className="mb-6">
        <div className="flex items-end space-x-3 mb-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Pokémon Index
            </label>
            <input 
              type="number" 
              min="0"
              value={pokemonIndex}
              onChange={(e) => setPokemonIndex(parseInt(e.target.value))}
              className="p-2 border rounded w-20"
            />
          </div>
          
          <button
            onClick={mintPokemon}
            disabled={isMinting || !account}
            className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition disabled:opacity-50"
          >
            {isMinting ? 'Minting...' : 'Mint Pokémon'}
          </button>
          
          <button
            onClick={checkPokemonCount}
            disabled={!account}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition disabled:opacity-50"
          >
            Check Pokémon Count
          </button>
        </div>
      </div>
      
      {result && (
        <div className={`p-3 rounded ${result.includes('Error') ? 'bg-red-50 text-red-800' : 'bg-blue-50 text-blue-800'}`}>
          {result}
        </div>
      )}
      
      {!account && (
        <p className="mt-4 text-red-600">
          Please connect your wallet to mint Pokémon.
        </p>
      )}
    </div>
  );
}

frontend/src/components/AddressChecker.tsx
// src/components/AddressChecker.tsx
'use client';

import { useWeb3 } from '@/contexts/Web3Context';
import { useState, useEffect } from 'react';
import contractAddresses from '@/lib/contracts/addresses.json';

export default function AddressChecker() {
  const { account, nftContract, marketplaceContract } = useWeb3();
  const [owner, setOwner] = useState<string | null>(null);
  const [isOwner, setIsOwner] = useState<boolean>(false);
  
  useEffect(() => {
    const checkOwner = async () => {
      if (nftContract && account) {
        try {
          // Try to get the owner of the NFT contract
          const contractOwner = await nftContract.owner();
          setOwner(contractOwner);
          setIsOwner(contractOwner.toLowerCase() === account.toLowerCase());
        } catch (error) {
          console.error("Error checking owner:", error);
        }
      }
    };
    
    checkOwner();
  }, [nftContract, account]);
  
  return (
    <div className="bg-white p-4 rounded-lg shadow-md mb-6 max-w-4xl mx-auto text-left">
      <h2 className="text-lg font-semibold mb-2">Contract Information</h2>
      <div className="space-y-2 text-sm">
        <p><span className="font-medium">Your Address:</span> {account || 'Not connected'}</p>
        <p><span className="font-medium">NFT Contract:</span> {nftContract?.target || 'Not connected'}</p>
        <p><span className="font-medium">Marketplace Contract:</span> {marketplaceContract?.target || 'Not connected'}</p>
        <p><span className="font-medium">Expected NFT Address:</span> {contractAddresses.nft}</p>
        <p><span className="font-medium">Expected Marketplace Address:</span> {contractAddresses.marketplace}</p>
        <p><span className="font-medium">Contract Owner:</span> {owner || 'Unknown'}</p>
        <p>
          <span className="font-medium">Owner Status:</span> 
          {isOwner 
            ? <span className="text-green-600">You are the owner</span> 
            : <span className="text-red-600">You are NOT the owner</span>}
        </p>
        <div className="mt-4 border-t pt-2">
          <p><span className="font-medium">Note:</span> If your wallet address doesn't match the contract owner, 
          you might not have permission to mint specific Pokémon. Try using the random mint function or deploy 
          a new contract and make your address the owner.</p>
        </div>
      </div>
    </div>
  );
}

frontend/src/contexts/Web3Context.tsx
// src/contexts/Web3Context.tsx
'use client';

import { createContext, useContext, useState, useEffect } from 'react';
import { ethers } from 'ethers';
import nftAbi from '@/lib/contracts/PokemonNFT.json';
import marketplaceAbi from '@/lib/contracts/PokemonMarketplace.json';
import contractAddresses from '@/lib/contracts/addresses.json';

type Web3ContextType = {
  provider: ethers.BrowserProvider | null;
  signer: ethers.Signer | null;
  account: string | null;
  nftContract: ethers.Contract | null;
  marketplaceContract: ethers.Contract | null;
  connectWallet: () => Promise<void>;
  isConnecting: boolean;
  error: string | null;
};

type Web3ProviderProps = {
  children: React.ReactNode;
};

const Web3Context = createContext<Web3ContextType | null>(null);

export function Web3Provider({ children }: Web3ProviderProps) {
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [signer, setSigner] = useState<ethers.Signer | null>(null);
  const [account, setAccount] = useState<string | null>(null);
  const [nftContract, setNftContract] = useState<ethers.Contract | null>(null);
  const [marketplaceContract, setMarketplaceContract] = useState<ethers.Contract | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const initializeWeb3 = async () => {
    try {
      // Check if MetaMask is installed
      if (typeof window !== 'undefined' && window.ethereum) {
        const provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(provider);

        // Check if already connected
        const accounts = await provider.listAccounts();
        if (accounts.length > 0) {
          const signer = await provider.getSigner();
          setSigner(signer);
          setAccount(accounts[0].address);

          // Initialize contracts
          const nftContract = new ethers.Contract(
            contractAddresses.nft,
            nftAbi.abi,
            signer
          );
          const marketplaceContract = new ethers.Contract(
            contractAddresses.marketplace,
            marketplaceAbi.abi,
            signer
          );

          setNftContract(nftContract);
          setMarketplaceContract(marketplaceContract);
        }
      } else {
        setError('MetaMask is not installed. Please install MetaMask to use this app.');
      }
    } catch (err) {
      console.error('Failed to initialize Web3', err);
      setError('Failed to initialize Web3. Please refresh the page and try again.');
    }
  };

  const connectWallet = async () => {
    setIsConnecting(true);
    setError(null);
    
    try {
      if (provider) {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        const signer = await provider.getSigner();
        const address = await signer.getAddress();
        
        setSigner(signer);
        setAccount(address);
        
        // Initialize contracts with signer
        const nftContract = new ethers.Contract(
          contractAddresses.nft,
          nftAbi.abi,
          signer
        );
        const marketplaceContract = new ethers.Contract(
          contractAddresses.marketplace,
          marketplaceAbi.abi,
          signer
        );

        setNftContract(nftContract);
        setMarketplaceContract(marketplaceContract);
      } else {
        setError('Provider not initialized. Please refresh the page.');
      }
    } catch (err) {
      console.error('Error connecting wallet:', err);
      setError('Failed to connect wallet. Please try again.');
    } finally {
      setIsConnecting(false);
    }
  };

  useEffect(() => {
    initializeWeb3();
    
    // Setup event listeners for account changes
    if (typeof window !== 'undefined' && window.ethereum) {
      window.ethereum.on('accountsChanged', (accounts: string[]) => {
        if (accounts.length === 0) {
          // User disconnected their wallet
          setSigner(null);
          setAccount(null);
          setNftContract(null);
          setMarketplaceContract(null);
        } else {
          // Account changed, reload the page for simplicity
          window.location.reload();
        }
      });
      
      window.ethereum.on('chainChanged', () => {
        window.location.reload();
      });
    }
    
    return () => {
      // Cleanup event listeners
      if (window.ethereum) {
        window.ethereum.removeAllListeners();
      }
    };
  }, []);

  const value = {
    provider,
    signer,
    account,
    nftContract,
    marketplaceContract,
    connectWallet,
    isConnecting,
    error
  };

  return <Web3Context.Provider value={value}>{children}</Web3Context.Provider>;
}

export function useWeb3() {
  const context = useContext(Web3Context);
  if (!context) {
    throw new Error('useWeb3 must be used within a Web3Provider');
  }
  return context;
}

